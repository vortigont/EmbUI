// This framework originaly based on JeeUI2 lib used under MIT License Copyright (c) 2019 Marsel Akhkamov
// then re-written and named by (c) 2020 Anton Zolotarev (obliterator) (https://github.com/anton-zolotarev)
// also many thanks to Vortigont (https://github.com/vortigont), kDn (https://github.com/DmytroKorniienko)
// and others people

#include "EmbUI.h"
#include "wi-fi.h"

void EmbUI::wifi_connect(const char *ssid, const char *pwd)
{
    String _ssid(ssid); String _pwd(pwd);   // I need objects to pass it to lambda
    embuischedw.set(WIFI_BEGIN_DELAY * TASK_SECOND, TASK_ONCE,
        [_ssid, _pwd](){
                LOG(printf_P, PSTR("UI WiFi: client connecting to SSID:'%s', pwd:'%s'\n"), _ssid.c_str(), _pwd.isEmpty() ? P_EMPTY : _pwd.c_str());
                #ifdef ESP32
                    WiFi.disconnect();
                    WiFi.config(INADDR_NONE, INADDR_NONE, INADDR_NONE);
                #endif

                _ssid.length() ? WiFi.begin(_ssid.c_str(), _pwd.c_str()) : WiFi.begin();
                ts.getCurrentTask()->disable();
        }
    );

    embuischedw.restartDelayed();
}


void EmbUI::wifi_setmode(WiFiMode_t mode){
    LOG(printf_P, PSTR("UI WiFi: set mode: %d\n"), mode);
    WiFi.mode(mode);
}

/*use mdns for host name resolution*/
void EmbUI::setup_mDns(){

#ifdef ESP8266
    if (MDNS.isRunning())
#endif
        MDNS.end();

    if (!MDNS.begin(hostname())){
        LOG(println, F("UI mDNS: Error setting up responder!"));
        MDNS.end();
        return;
    }

    MDNS.addService(F("http"), F("tcp"), 80);
    //MDNS.addService(F("ftp"), F("tcp"), 21);
    MDNS.addService(F("txt"), F("udp"), 4243);
    LOG(printf_P, PSTR("UI mDNS: responder started: %s.local\n"), hostname());
}

/**
 * Configure esp's internal AP
 * default is to configure credentials from the config
 * bool force - reapply credentials even if AP is already started, exit otherwise
 */
void EmbUI::wifi_setAP(bool force){
    // check if AP is already started
    if ((bool)(WiFi.getMode() & WIFI_AP) & !force)
        return;

    // clear password if invalid 
    if (cfg[FPSTR(P_APpwd)] && strlen(cfg[FPSTR(P_APpwd)]) < WIFI_PSK_MIN_LENGTH)
        var_remove(FPSTR(P_APpwd));

    LOG(printf_P, PSTR("UI WiFi: set AP params to SSID:'%s', pwd:'%s'\n"), hostname(), cfg[FPSTR(P_APpwd)] ? cfg[FPSTR(P_APpwd)].as<const char*>() : P_EMPTY);

    WiFi.softAP(hostname(), cfg[FPSTR(P_APpwd)]);

    // run mDNS in WiFi-AP mode
    setup_mDns();
}


void EmbUI::wifi_updateAP() {
    wifi_setAP(true);

    if (paramVariant(FPSTR(P_APonly))){
        LOG(println, F("UI WiFi: Force AP mode"));
        WiFi.enableAP(true);
        WiFi.enableSTA(false);
    }
}

/**
 * @brief get/set device hosname
 * if hostname has not been set or empty returns autogenerated __IDPREFIX-[mac_id] hostname
 * autogenerated hostname is NOT saved into persistent config
 * 
 * @return const char* current hostname
 */
const char* EmbUI::hostname(){

    JsonVariantConst h = paramVariant(FPSTR(P_hostname));
    if (h && strlen(h.as<const char*>()))
        return h.as<const char*>();

    if (autohostname.get())
        return autohostname.get();

    autohostname.reset(new char[sizeof(__IDPREFIX) + sizeof(mc) * 2]);
    sprintf_P(autohostname.get(), PSTR(__IDPREFIX "-%s"), mc);
    LOG(printf_P, PSTR("generate autohostname: %s\n"), autohostname.get());

    return autohostname.get();
}

const char* EmbUI::hostname(const char* name){
    var_dropnulls(FPSTR(P_hostname), (char*)name);
    return hostname();
};
